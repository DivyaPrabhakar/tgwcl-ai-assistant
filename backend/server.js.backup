// server.js
const express = require("express");
const cors = require("cors");
const Airtable = require("airtable");
const OpenAI = require("openai");
const fs = require("fs").promises;
const path = require("path");
require("dotenv").config();

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json());

// Data persistence configuration
const DATA_DIR = path.join(__dirname, "cached_data");
const CACHE_EXPIRY = 7 * 24 * 60 * 60 * 1000; // 7 days instead of 30 minutes

// In-memory cache
const cache = {
  items: { data: null, timestamp: null, lastRecordId: null },
  inactiveItems: { data: null, timestamp: null, lastRecordId: null },
  outfits: { data: null, timestamp: null, lastRecordId: null },
  usageLog: { data: null, timestamp: null, lastRecordId: null },
  inspiration: { data: null, timestamp: null, lastRecordId: null },
  shoppingList: { data: null, timestamp: null, lastRecordId: null },
  avoids: { data: null, timestamp: null, lastRecordId: null },
};

// Ensure data directory exists
async function ensureDataDir() {
  try {
    await fs.mkdir(DATA_DIR, { recursive: true });
  } catch (error) {
    console.error("Error creating data directory:", error);
  }
}

// Load cached data from file
async function loadFromFile(key) {
  try {
    const filePath = path.join(DATA_DIR, `${key}.json`);
    const data = await fs.readFile(filePath, "utf8");
    const parsed = JSON.parse(data);
    console.log(`Loaded ${parsed.data?.length || 0} ${key} records from file`);
    return parsed;
  } catch (error) {
    console.log(`No cached file found for ${key}, starting fresh`);
    return { data: [], timestamp: null, lastRecordId: null };
  }
}

// Save data to file
async function saveToFile(key, cacheEntry) {
  try {
    const filePath = path.join(DATA_DIR, `${key}.json`);
    await fs.writeFile(filePath, JSON.stringify(cacheEntry, null, 2));
    console.log(`Saved ${cacheEntry.data?.length || 0} ${key} records to file`);
  } catch (error) {
    console.error(`Error saving ${key} to file:`, error);
  }
}

// Check if cache is valid (7 days instead of 30 minutes)
function isCacheValid(cacheEntry) {
  if (!cacheEntry.data || !cacheEntry.timestamp) return false;
  return Date.now() - cacheEntry.timestamp < CACHE_EXPIRY;
}

// Update cache and save to file
async function updateCache(key, data, lastRecordId = null) {
  cache[key] = {
    data: data,
    timestamp: Date.now(),
    lastRecordId: lastRecordId,
    fetching: false,
  };
  await saveToFile(key, cache[key]);
  console.log(`Cache updated for ${key}: ${data.length} records`);
}

// Load all cached data from files on startup
async function loadAllCachedData() {
  console.log("Loading cached data from files...");
  for (const key of Object.keys(cache)) {
    cache[key] = await loadFromFile(key);
  }
}

// Initialize Airtable bases (only if API key is provided)
let airtable, closetBase, referencesBase, finishedBase;
if (process.env.AIRTABLE_API_KEY) {
  airtable = new Airtable({
    apiKey: process.env.AIRTABLE_API_KEY,
  });
  closetBase = airtable.base(process.env.AIRTABLE_CLOSET_BASE_ID);
  referencesBase = airtable.base(process.env.AIRTABLE_REFERENCES_BASE_ID);
  finishedBase = airtable.base(process.env.AIRTABLE_FINISHED_BASE_ID);
}

// Initialize OpenAI (only if API key is provided)
let openai;
if (process.env.OPENAI_API_KEY) {
  openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
  });
}

// Airtable service functions
class WardrobeService {
  async fetchIncrementally(
    base,
    tableName,
    cacheKey,
    view = null,
    sortField = null
  ) {
    if (!base) {
      console.log(`No base available for ${tableName}, returning cached data`);
      return cache[cacheKey].data || [];
    }

    // Prevent simultaneous fetches
    if (cache[cacheKey].fetching) {
      console.log(`Already fetching ${tableName}, returning cached data`);
      return cache[cacheKey].data || [];
    }

    cache[cacheKey].fetching = true;

    try {
      const existingData = cache[cacheKey].data || [];
      const lastRecordId = cache[cacheKey].lastRecordId;

      console.log(
        `Fetching ${tableName} incrementally... (${existingData.length} existing records, lastRecordId: ${lastRecordId})`
      );

      const selectOptions = {};
      if (view) {
        selectOptions.view = view;
      }
      if (sortField) {
        selectOptions.sort = [{ field: sortField, direction: "desc" }];
      }

      let allRecords = [];
      let pageCount = 0;
      const maxPages = 50; // Safety limit

      console.log(
        `Starting to fetch ${tableName} with options:`,
        selectOptions
      );

      await base(tableName)
        .select(selectOptions)
        .eachPage((pageRecords, fetchNextPage) => {
          pageCount++;
          console.log(
            `Processing page ${pageCount} with ${pageRecords.length} records for ${tableName}`
          );

          // If this is the first fetch (no lastRecordId), get all records
          if (!lastRecordId) {
            for (const record of pageRecords) {
              allRecords.push({
                id: record.id,
                status: cacheKey.includes("inactive") ? "inactive" : "active",
                ...record.fields,
              });
            }

            // Continue to next page if we haven't hit our safety limit
            if (pageCount < maxPages) {
              fetchNextPage();
            } else {
              console.log(`Hit page limit for ${tableName}, stopping`);
            }
          } else {
            // If we have a lastRecordId, look for new records
            let foundLastRecord = false;

            for (const record of pageRecords) {
              if (record.id === lastRecordId) {
                foundLastRecord = true;
                console.log(
                  `Found last record ${lastRecordId} for ${tableName}, stopping`
                );
                break;
              }

              // This is a new record
              allRecords.push({
                id: record.id,
                status: cacheKey.includes("inactive") ? "inactive" : "active",
                ...record.fields,
              });
            }

            if (!foundLastRecord && pageCount < maxPages) {
              fetchNextPage();
            } else {
              console.log(
                `Stopping fetch for ${tableName}. Found last record: ${foundLastRecord}, Page: ${pageCount}`
              );
            }
          }
        });

      // For first fetch, use all new records
      // For incremental, combine new records with existing
      const finalRecords = lastRecordId
        ? [...allRecords, ...existingData]
        : allRecords;
      const newLastRecordId =
        finalRecords.length > 0 ? finalRecords[0].id : lastRecordId;

      await updateCache(cacheKey, finalRecords, newLastRecordId);
      console.log(
        `Successfully fetched ${allRecords.length} ${
          lastRecordId ? "new" : "total"
        } ${tableName} records`
      );

      return finalRecords;
    } catch (error) {
      console.error(`Error fetching ${tableName}:`, error.message);
      console.error(`Full error:`, error);
      if (
        error.message &&
        (error.message.includes("quota") ||
          error.message.includes("rate limit"))
      ) {
        console.log(
          `Quota/rate limit hit while fetching ${tableName}, using existing data`
        );
        return cache[cacheKey].data || [];
      }
      console.log(`Unknown error for ${tableName}, using existing data`);
      return cache[cacheKey].data || [];
    } finally {
      cache[cacheKey].fetching = false;
    }
  }

  async getItems(forceRefresh = false) {
    if (
      !forceRefresh &&
      isCacheValid(cache.items) &&
      cache.items.data?.length > 0
    ) {
      console.log("Returning cached items");
      return cache.items.data;
    }

    return await this.fetchIncrementally(
      closetBase,
      "Items",
      "items",
      "All items"
    );
  }

  async getInactiveItems(forceRefresh = false) {
    if (
      !forceRefresh &&
      isCacheValid(cache.inactiveItems) &&
      cache.inactiveItems.data?.length > 0
    ) {
      console.log("Returning cached inactive items");
      return cache.inactiveItems.data;
    }

    return await this.fetchIncrementally(
      finishedBase,
      "Inactive items",
      "inactiveItems"
    );
  }

  async getAllItems(forceRefresh = false) {
    const [active, inactive] = await Promise.all([
      this.getItems(forceRefresh),
      this.getInactiveItems(forceRefresh),
    ]);
    return [...active, ...inactive];
  }

  async getOutfits(forceRefresh = false) {
    if (
      !forceRefresh &&
      isCacheValid(cache.outfits) &&
      cache.outfits.data?.length > 0
    ) {
      console.log("Returning cached outfits");
      return cache.outfits.data;
    }

    return await this.fetchIncrementally(
      closetBase,
      "Outfits",
      "outfits",
      "Evaluation view",
      "id"
    );
  }

  async getUsageLog(forceRefresh = false) {
    if (
      !forceRefresh &&
      isCacheValid(cache.usageLog) &&
      cache.usageLog.data?.length > 0
    ) {
      console.log("Returning cached usage log");
      return cache.usageLog.data;
    }

    // Try different possible configurations for your Usage Log table
    const possibleConfigs = [
      { table: "Usage Log", view: "Detailed view", sort: "date_worn" },
      { table: "Usage Log", view: "Grid view", sort: "date_worn" },
      { table: "Usage Log", view: "All records", sort: "date_worn" },
      { table: "Usage Log", view: "Detailed view", sort: "Date" },
      { table: "Usage Log", view: "Grid view", sort: "Date" },
      { table: "Usage Log", sort: "date_worn" }, // No view specified
      { table: "Usage Log", sort: "Date" }, // No view specified
      { table: "Usage Log" }, // No view or sort
    ];

    for (const config of possibleConfigs) {
      try {
        console.log(`Trying Usage Log config:`, config);
        return await this.fetchIncrementally(
          closetBase,
          config.table,
          "usageLog",
          config.view,
          config.sort
        );
      } catch (error) {
        console.log(
          `Config failed: ${config.view || "no view"} with ${
            config.sort || "no sort"
          }: ${error.message}`
        );
        continue;
      }
    }

    console.error("All Usage Log configurations failed, returning empty array");
    return [];
  }

  async getInspiration(forceRefresh = false) {
    if (
      !forceRefresh &&
      isCacheValid(cache.inspiration) &&
      cache.inspiration.data?.length > 0
    ) {
      console.log("Returning cached inspiration");
      return cache.inspiration.data;
    }

    return await this.fetchIncrementally(
      referencesBase,
      "Inspiration",
      "inspiration"
    );
  }

  async getShoppingList(forceRefresh = false) {
    if (
      !forceRefresh &&
      isCacheValid(cache.shoppingList) &&
      cache.shoppingList.data?.length > 0
    ) {
      console.log("Returning cached shopping list");
      return cache.shoppingList.data;
    }

    return await this.fetchIncrementally(
      referencesBase,
      "Shopping list",
      "shoppingList"
    );
  }

  async getAvoids(forceRefresh = false) {
    if (
      !forceRefresh &&
      isCacheValid(cache.avoids) &&
      cache.avoids.data?.length > 0
    ) {
      console.log("Returning cached avoids");
      return cache.avoids.data;
    }

    return await this.fetchIncrementally(referencesBase, "Avoids", "avoids");
  }

  async analyzeUsagePatterns(forceRefresh = false) {
  console.log("=== ANALYZE USAGE PATTERNS START ===");
  
  const [activeItems, inactiveItems, outfits, usageLog] = await Promise.all([
    this.getItems(forceRefresh),
    this.getInactiveItems(forceRefresh),
    this.getOutfits(forceRefresh),
    this.getUsageLog(forceRefresh),
  ]);

  console.log("analyzeUsagePatterns - Raw data counts:", {
    activeItems: activeItems?.length || 0,
    inactiveItems: inactiveItems?.length || 0,
    outfits: outfits?.length || 0,
    usageLog: usageLog?.length || 0
  });

  // Show sample data structure
  if (activeItems?.length > 0) {
    console.log("Sample active item:", JSON.stringify(activeItems[0], null, 2));
  }
  if (usageLog?.length > 0) {
    console.log("Sample usage log entry:", JSON.stringify(usageLog[0], null, 2));
  }

  // Create usage analytics
  const itemUsage = {};
  const seasonalTrends = {};
  const occasionTrends = {};

  // Analyze usage log
  console.log("Processing usage log entries...");
  usageLog.forEach((record, index) => {
    if (index < 3) {
      console.log(`Usage record ${index}:`, {
        Item: record["Item"] || record.Item,
        Date: record["Date"] || record.Date,
        Occasion: record["Occasion"] || record.Occasion
      });
    }

    if (record["Item"] || record.Item) {
      const itemKey = Array.isArray(record["Item"]) 
        ? record["Item"][0] 
        : (record["Item"] || record.Item);
      itemUsage[itemKey] = (itemUsage[itemKey] || 0) + 1;
    }

    // Seasonal analysis
    const dateField = record.Date || record["Date"];
    if (dateField) {
      try {
        const month = new Date(dateField).getMonth();
        const season = this.getSeason(month);
        seasonalTrends[season] = (seasonalTrends[season] || 0) + 1;
      } catch (e) {
        console.log("Error parsing date:", dateField, e.message);
      }
    }

    // Occasion analysis
    const occasionField = record.Occasion || record["Occasion"];
    if (occasionField) {
      occasionTrends[occasionField] = (occasionTrends[occasionField] || 0) + 1;
    }
  });

  console.log("Processed usage patterns:", {
    itemUsageCount: Object.keys(itemUsage).length,
    seasonalTrendsCount: Object.keys(seasonalTrends).length,
    occasionTrendsCount: Object.keys(occasionTrends).length
  });

  const result = {
    totalActiveItems: activeItems?.length || 0,
    totalInactiveItems: inactiveItems?.length || 0,
    totalOutfits: outfits?.length || 0,
    totalUsageEntries: usageLog?.length || 0,
    mostWornItems: Object.entries(itemUsage)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 10)
      .map(([itemKey, count]) => ({
        item: itemKey,
        usage: count,
      })),
    leastWornItems: Object.entries(itemUsage)
      .sort(([, a], [, b]) => a - b)
      .slice(0, 10)
      .map(([itemKey, count]) => ({
        item: itemKey,
        usage: count,
      })),
    seasonalTrends,
    occasionTrends,
    inactiveItemsAnalysis: this.analyzeInactiveItems(inactiveItems),
  };

  console.log("Final analytics result:", {
    totalActiveItems: result.totalActiveItems,
    totalUsageEntries: result.totalUsageEntries,
    seasonalTrendsKeys: Object.keys(result.seasonalTrends),
    mostWornItemsCount: result.mostWornItems.length
  });

  console.log("=== ANALYZE USAGE PATTERNS END ===");
  return result;
}

  getSeason(month) {
    if (month >= 2 && month <= 4) return "Spring";
    if (month >= 5 && month <= 7) return "Summer";
    if (month >= 8 && month <= 10) return "Fall";
    return "Winter";
  }

  analyzeInactiveItems(inactiveItems) {
    const reasons = {};
    const categories = {};

    inactiveItems.forEach((item) => {
      if (item["Reason"]) {
        reasons[item["Reason"]] = (reasons[item["Reason"]] || 0) + 1;
      }

      if (item["Category"]) {
        categories[item["Category"]] = (categories[item["Category"]] || 0) + 1;
      }
    });

    return { reasons, categories };
  }

  async getCostAnalysis(forceRefresh = false) {
    const [activeItems, inactiveItems, usageLog] = await Promise.all([
      this.getItems(forceRefresh),
      this.getInactiveItems(forceRefresh),
      this.getUsageLog(forceRefresh),
    ]);

    const allItems = [...activeItems, ...inactiveItems];

    const costPerWear = allItems
      .map((item) => {
        const itemName = item.Name || item.name;
        const wearCount = usageLog.filter((u) => {
          const logItem = Array.isArray(u["Item"]) ? u["Item"][0] : u["Item"];
          return logItem === itemName || logItem === item.id;
        }).length;

        const cost = item.Cost || item.cost || 0;
        return {
          name: itemName,
          cost,
          wearCount,
          costPerWear: wearCount > 0 ? cost / wearCount : cost,
          status: item.status,
        };
      })
      .sort((a, b) => a.costPerWear - b.costPerWear);

    return {
      totalInvestment: allItems.reduce(
        (sum, item) => sum + (item.Cost || item.cost || 0),
        0
      ),
      activeWardrobeValue: activeItems.reduce(
        (sum, item) => sum + (item.Cost || item.cost || 0),
        0
      ),
      bestValueItems: costPerWear
        .filter((item) => item.wearCount > 0)
        .slice(0, 10),
      worstValueItems: costPerWear
        .filter((item) => item.wearCount > 0)
        .slice(-10),
      unwornItems: costPerWear.filter(
        (item) => item.wearCount === 0 && item.status === "active"
      ),
    };
  }
}

const wardrobeService = new WardrobeService();

// AI Service
class AIService {
  async generateResponse(message, context, wardrobeData) {
    if (!openai) {
      return "I'm sorry, but the AI service is not configured. Please set up your OpenAI API key to enable AI responses.";
    }

    const systemPrompt = `You are a personal wardrobe AI assistant with access to detailed wardrobe data. You must provide SPECIFIC, DATA-DRIVEN responses using the exact information provided.

CURRENT WARDROBE DATA:
- Active Items: ${wardrobeData.detailedAnalytics?.totalActiveItems || 0} items
- Total Outfits: ${
      wardrobeData.detailedAnalytics?.totalOutfits || 0
    } outfits logged
- Usage Entries: ${
      wardrobeData.detailedAnalytics?.totalUsageEntries || 0
    } individual wears tracked
- Total Investment: ${wardrobeData.costInsights?.totalInvestment || 0}

SPECIFIC SEASONAL DATA:
${JSON.stringify(wardrobeData.detailedAnalytics?.seasonalTrends || {}, null, 2)}

SPECIFIC OCCASION TRENDS:
${JSON.stringify(wardrobeData.detailedAnalytics?.occasionTrends || {}, null, 2)}

MOST WORN ITEMS (with exact wear counts):
${
  wardrobeData.detailedAnalytics?.mostWornItems
    ?.map((item) => `- ${item.item}: ${item.usage} wears`)
    .join("\n") || "No usage data available"
}

LEAST WORN ITEMS (with exact wear counts):
${
  wardrobeData.detailedAnalytics?.leastWornItems
    ?.map((item) => `- ${item.item}: ${item.usage} wears`)
    .join("\n") || "No usage data available"
}

BEST VALUE ITEMS (cost per wear):
${
  wardrobeData.costInsights?.bestValueItems
    ?.map(
      (item) =>
        `- ${item.name}: ${item.costPerWear?.toFixed(2)}/wear (${
          item.wearCount
        } wears, ${item.cost} cost)`
    )
    .join("\n") || "No cost data available"
}

SAMPLE RECENT USAGE ENTRIES:
${
  wardrobeData.recentUsageSample
    ?.map(
      (usage) =>
        `- ${usage.date}: ${usage.item} for ${
          usage.occasion || "unspecified"
        } (${usage.weather || "no weather data"})`
    )
    .join("\n") || "No recent usage data"
}

SAMPLE ACTIVE ITEMS:
${
  wardrobeData.activeItemsSample
    ?.map(
      (item) =>
        `- ${item.name}: ${item.category || "unknown category"}, ${
          item.color || "unknown color"
        }, ${item.cost || 0}`
    )
    .join("\n") || "No item details available"
}

SHOPPING LIST ITEMS:
${
  wardrobeData.referenceData?.shoppingListSample
    ?.map((item) => `- ${item.Item || item.Name || "Unknown item"}`)
    .join("\n") || "No shopping list items"
}

INACTIVE ITEMS ANALYSIS:
${JSON.stringify(
  wardrobeData.detailedAnalytics?.inactiveItemsAnalysis || {},
  null,
  2
)}

CRITICAL INSTRUCTIONS:
1. ALWAYS use specific numbers from the data provided above
2. ALWAYS reference actual item names when available
3. ALWAYS cite specific wear counts, costs, and dates
4. NEVER give generic advice - only use the actual data provided
5. When discussing seasonal patterns, use the exact seasonal trends numbers
6. When discussing cost analysis, use exact dollar amounts and wear counts
7. If asked about specific items, search through the provided sample data
8. Always start responses with "Based on your wardrobe data..." and cite specific numbers

EXAMPLE GOOD RESPONSE:
"Based on your wardrobe data with ${
      wardrobeData.detailedAnalytics?.totalUsageEntries || 0
    } usage entries, your seasonal wearing patterns show: Spring has ${
      wardrobeData.detailedAnalytics?.seasonalTrends?.Spring || 0
    } wears, Summer has ${
      wardrobeData.detailedAnalytics?.seasonalTrends?.Summer || 0
    } wears, Fall has ${
      wardrobeData.detailedAnalytics?.seasonalTrends?.Fall || 0
    } wears, and Winter has ${
      wardrobeData.detailedAnalytics?.seasonalTrends?.Winter || 0
    } wears. Your most active season is [specific season with highest number]."

Be conversational but ALWAYS data-specific. Never give generic wardrobe advice.`;

    const messages = [
      { role: "system", content: systemPrompt },
      ...context.map((msg) => ({
        role: msg.type === "user" ? "user" : "assistant",
        content: msg.content,
      })),
      { role: "user", content: message },
    ];

    try {
      const completion = await openai.chat.completions.create({
        model: "gpt-4o", // Upgraded to GPT-4o (newest, fastest GPT-4)
        messages: messages,
        max_tokens: 800, // Increased for more detailed responses
        temperature: 0.3,
      });

      return completion.choices[0].message.content;
    } catch (error) {
      if (error.code === "insufficient_quota") {
        return "I'm currently experiencing quota limitations with the AI service. I can still access your wardrobe data, but AI responses are temporarily limited. Your data is safely cached and will be available when the quota resets.";
      }
      throw error;
    }
  }

  async evaluatePurchase(itemUrl, description, wardrobeData) {
    if (!openai) {
      return "I'm sorry, but the AI service is not configured. Please set up your OpenAI API key to enable purchase evaluation.";
    }

    const prompt = `Based on this wardrobe data:
ACTIVE: ${wardrobeData.activeItems?.length || 0} items
INACTIVE: ${wardrobeData.inactiveItems?.length || 0} items  
ANALYTICS: ${JSON.stringify(wardrobeData.analytics, null, 2)}

Evaluate: ${description}
URL: ${itemUrl}

Provide a recommendation with specific reasoning.`;

    try {
      const completion = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "user", content: prompt }],
        max_tokens: 600,
        temperature: 0.3,
      });

      return completion.choices[0].message.content;
    } catch (error) {
      if (error.code === "insufficient_quota") {
        return "AI purchase evaluation is temporarily limited due to quota restrictions. However, I can tell you that based on your data, you have detailed information about your wardrobe patterns that would inform a good decision.";
      }
      throw error;
    }
  }
}

const aiService = new AIService();

// Initialize app
async function initializeApp() {
  await ensureDataDir();
  await loadAllCachedData();

  // Check if we have any cached data
  const totalCachedRecords = Object.values(cache).reduce((sum, cacheEntry) => {
    return sum + (cacheEntry.data ? cacheEntry.data.length : 0);
  }, 0);

  console.log(`Total cached records: ${totalCachedRecords}`);

  if (totalCachedRecords === 0) {
    console.log(
      "No cached data found. Server is ready - use API endpoints to fetch data when quota allows."
    );
    console.log("Try: POST http://localhost:3001/api/refresh/shopping-list");
  } else {
    console.log("Using existing cached data. Server ready for chat!");
  }

  // Don't try to fetch anything on startup - let user control when to fetch
  console.log("Startup completed. Ready to serve requests.");
}

// Routes
app.get("/api/health", (req, res) => {
  res.json({ status: "OK", timestamp: new Date().toISOString() });
});

// 2. Add a simple test endpoint to verify data flow
app.get("/api/test/simple-data", async (req, res) => {
  try {
    console.log("=== SIMPLE DATA TEST ===");
    
    // Test each data source individually
    const items = await wardrobeService.getItems(false);
    console.log("Items test:", items?.length || 0);
    
    const usageLog = await wardrobeService.getUsageLog(false);
    console.log("Usage log test:", usageLog?.length || 0);
    
    const analytics = await wardrobeService.analyzeUsagePatterns(false);
    console.log("Analytics test:", {
      totalActiveItems: analytics?.totalActiveItems,
      totalUsageEntries: analytics?.totalUsageEntries
    });

    res.json({
      itemsCount: items?.length || 0,
      usageLogCount: usageLog?.length || 0,
      analyticsKeys: analytics ? Object.keys(analytics) : [],
      totalActiveFromAnalytics: analytics?.totalActiveItems || 0,
      totalUsageFromAnalytics: analytics?.totalUsageEntries || 0,
      sampleItem: items?.[0] || null,
      sampleUsage: usageLog?.[0] || null
    });
  } catch (error) {
    console.error("Simple data test error:", error);
    res.status(500).json({ error: error.message });
  }
});

// 3. Enhanced chat endpoint with extensive logging
app.post("/api/chat", async (req, res) => {
  try {
    const { message, context = [] } = req.body;
    console.log("=== CHAT REQUEST START ===");
    console.log("Message:", message);

    // Fetch data with detailed logging
    console.log("Fetching wardrobe data...");
    const startTime = Date.now();
    
    const analytics = await wardrobeService.analyzeUsagePatterns(false);
    console.log("Analytics fetch time:", Date.now() - startTime, "ms");
    console.log("Analytics result:", {
      hasAnalytics: !!analytics,
      keys: analytics ? Object.keys(analytics) : [],
      totalActiveItems: analytics?.totalActiveItems,
      totalUsageEntries: analytics?.totalUsageEntries
    });

    const costAnalysis = await wardrobeService.getCostAnalysis(false);
    console.log("Cost analysis:", {
      hasCostAnalysis: !!costAnalysis,
      keys: costAnalysis ? Object.keys(costAnalysis) : []
    });

    // Create the exact structure the AI expects
    const wardrobeData = {
      detailedAnalytics: analytics,
      costInsights: costAnalysis,
      // Add basic counts as backup
      rawCounts: {
        totalActiveItems: analytics?.totalActiveItems || 0,
        totalUsageEntries: analytics?.totalUsageEntries || 0,
        totalOutfits: analytics?.totalOutfits || 0
      }
    };

    console.log("Final wardrobe data structure:", {
      hasDetailedAnalytics: !!wardrobeData.detailedAnalytics,
      hasCostInsights: !!wardrobeData.costInsights,
      rawCounts: wardrobeData.rawCounts
    });

    // Generate AI response
    console.log("Calling AI service...");
    const response = await aiService.generateResponse(message, context, wardrobeData);
    console.log("AI response length:", response?.length || 0);
    console.log("=== CHAT REQUEST END ===");

    res.json({ response });
  } catch (error) {
    console.error("Chat error:", error);
    res.status(500).json({ 
      error: "Failed to process message", 
      details: error.message 
    });
  }
});

const wardrobeService = new WardrobeService();

// AI Service
class AIService {
  async generateResponse(message, context, wardrobeData) {
    if (!openai) {
      return "I'm sorry, but the AI service is not configured. Please set up your OpenAI API key to enable AI responses.";
    }

    const systemPrompt = `You are a personal wardrobe AI assistant with access to detailed wardrobe data. You must provide SPECIFIC, DATA-DRIVEN responses using the exact information provided.

CURRENT WARDROBE DATA:
- Active Items: ${wardrobeData.detailedAnalytics?.totalActiveItems || 0} items
- Total Outfits: ${
      wardrobeData.detailedAnalytics?.totalOutfits || 0
    } outfits logged
- Usage Entries: ${
      wardrobeData.detailedAnalytics?.totalUsageEntries || 0
    } individual wears tracked
- Total Investment: ${wardrobeData.costInsights?.totalInvestment || 0}

SPECIFIC SEASONAL DATA:
${JSON.stringify(wardrobeData.detailedAnalytics?.seasonalTrends || {}, null, 2)}

SPECIFIC OCCASION TRENDS:
${JSON.stringify(wardrobeData.detailedAnalytics?.occasionTrends || {}, null, 2)}

MOST WORN ITEMS (with exact wear counts):
${
  wardrobeData.detailedAnalytics?.mostWornItems
    ?.map((item) => `- ${item.item}: ${item.usage} wears`)
    .join("\n") || "No usage data available"
}

LEAST WORN ITEMS (with exact wear counts):
${
  wardrobeData.detailedAnalytics?.leastWornItems
    ?.map((item) => `- ${item.item}: ${item.usage} wears`)
    .join("\n") || "No usage data available"
}

BEST VALUE ITEMS (cost per wear):
${
  wardrobeData.costInsights?.bestValueItems
    ?.map(
      (item) =>
        `- ${item.name}: ${item.costPerWear?.toFixed(2)}/wear (${
          item.wearCount
        } wears, ${item.cost} cost)`
    )
    .join("\n") || "No cost data available"
}

SAMPLE RECENT USAGE ENTRIES:
${
  wardrobeData.recentUsageSample
    ?.map(
      (usage) =>
        `- ${usage.date}: ${usage.item} for ${
          usage.occasion || "unspecified"
        } (${usage.weather || "no weather data"})`
    )
    .join("\n") || "No recent usage data"
}

SAMPLE ACTIVE ITEMS:
${
  wardrobeData.activeItemsSample
    ?.map(
      (item) =>
        `- ${item.name}: ${item.category || "unknown category"}, ${
          item.color || "unknown color"
        }, ${item.cost || 0}`
    )
    .join("\n") || "No item details available"
}

SHOPPING LIST ITEMS:
${
  wardrobeData.referenceData?.shoppingListSample
    ?.map((item) => `- ${item.Item || item.Name || "Unknown item"}`)
    .join("\n") || "No shopping list items"
}

INACTIVE ITEMS ANALYSIS:
${JSON.stringify(
  wardrobeData.detailedAnalytics?.inactiveItemsAnalysis || {},
  null,
  2
)}

CRITICAL INSTRUCTIONS:
1. ALWAYS use specific numbers from the data provided above
2. ALWAYS reference actual item names when available
3. ALWAYS cite specific wear counts, costs, and dates
4. NEVER give generic advice - only use the actual data provided
5. When discussing seasonal patterns, use the exact seasonal trends numbers
6. When discussing cost analysis, use exact dollar amounts and wear counts
7. If asked about specific items, search through the provided sample data
8. Always start responses with "Based on your wardrobe data..." and cite specific numbers

EXAMPLE GOOD RESPONSE:
"Based on your wardrobe data with ${
      wardrobeData.detailedAnalytics?.totalUsageEntries || 0
    } usage entries, your seasonal wearing patterns show: Spring has ${
      wardrobeData.detailedAnalytics?.seasonalTrends?.Spring || 0
    } wears, Summer has ${
      wardrobeData.detailedAnalytics?.seasonalTrends?.Summer || 0
    } wears, Fall has ${
      wardrobeData.detailedAnalytics?.seasonalTrends?.Fall || 0
    } wears, and Winter has ${
      wardrobeData.detailedAnalytics?.seasonalTrends?.Winter || 0
    } wears. Your most active season is [specific season with highest number]."

Be conversational but ALWAYS data-specific. Never give generic wardrobe advice.`;

    const messages = [
      { role: "system", content: systemPrompt },
      ...context.map((msg) => ({
        role: msg.type === "user" ? "user" : "assistant",
        content: msg.content,
      })),
      { role: "user", content: message },
    ];

    try {
      const completion = await openai.chat.completions.create({
        model: "gpt-4o", // Upgraded to GPT-4o (newest, fastest GPT-4)
        messages: messages,
        max_tokens: 800, // Increased for more detailed responses
        temperature: 0.3,
      });

      return completion.choices[0].message.content;
    } catch (error) {
      if (error.code === "insufficient_quota") {
        return "I'm currently experiencing quota limitations with the AI service. I can still access your wardrobe data, but AI responses are temporarily limited. Your data is safely cached and will be available when the quota resets.";
      }
      throw error;
    }
  }

  async evaluatePurchase(itemUrl, description, wardrobeData) {
    if (!openai) {
      return "I'm sorry, but the AI service is not configured. Please set up your OpenAI API key to enable purchase evaluation.";
    }

    const prompt = `Based on this wardrobe data:
ACTIVE: ${wardrobeData.activeItems?.length || 0} items
INACTIVE: ${wardrobeData.inactiveItems?.length || 0} items  
ANALYTICS: ${JSON.stringify(wardrobeData.analytics, null, 2)}

Evaluate: ${description}
URL: ${itemUrl}

Provide a recommendation with specific reasoning.`;

    try {
      const completion = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "user", content: prompt }],
        max_tokens: 600,
        temperature: 0.3,
      });

      return completion.choices[0].message.content;
    } catch (error) {
      if (error.code === "insufficient_quota") {
        return "AI purchase evaluation is temporarily limited due to quota restrictions. However, I can tell you that based on your data, you have detailed information about your wardrobe patterns that would inform a good decision.";
      }
      throw error;
    }
  }
}

const aiService = new AIService();

// Initialize app
async function initializeApp() {
  await ensureDataDir();
  await loadAllCachedData();

  // Check if we have any cached data
  const totalCachedRecords = Object.values(cache).reduce((sum, cacheEntry) => {
    return sum + (cacheEntry.data ? cacheEntry.data.length : 0);
  }, 0);

  console.log(`Total cached records: ${totalCachedRecords}`);

  if (totalCachedRecords === 0) {
    console.log(
      "No cached data found. Server is ready - use API endpoints to fetch data when quota allows."
    );
    console.log("Try: POST http://localhost:3001/api/refresh/shopping-list");
  } else {
    console.log("Using existing cached data. Server ready for chat!");
  }

  // Don't try to fetch anything on startup - let user control when to fetch
  console.log("Startup completed. Ready to serve requests.");
}

// Routes
app.get("/api/health", (req, res) => {
  res.json({ status: "OK", timestamp: new Date().toISOString() });
});

// Cache status endpoint
app.get("/api/cache-status", (req, res) => {
  const status = {};
  Object.keys(cache).forEach((key) => {
    status[key] = {
      hasData: !!cache[key].data,
      recordCount: cache[key].data ? cache[key].data.length : 0,
      lastUpdated: cache[key].timestamp
        ? new Date(cache[key].timestamp).toISOString()
        : null,
      isValid: isCacheValid(cache[key]),
      lastRecordId: cache[key].lastRecordId,
    };
  });
  res.json(status);
});

// Force refresh specific table
app.post("/api/refresh/:table", async (req, res) => {
  try {
    const { table } = req.params;
    const methodMap = {
      items: "getItems",
      "inactive-items": "getInactiveItems",
      outfits: "getOutfits",
      "usage-log": "getUsageLog",
      inspiration: "getInspiration",
      "shopping-list": "getShoppingList",
      avoids: "getAvoids",
    };

    if (!methodMap[table]) {
      return res.status(400).json({ error: "Invalid table name" });
    }

    await wardrobeService[methodMap[table]](true);
    res.json({ message: `${table} refreshed successfully` });
  } catch (error) {
    console.error(`Error refreshing ${req.params.table}:`, error);
    res.status(500).json({ error: `Failed to refresh ${req.params.table}` });
  }
});

// Clear all cached data
app.post("/api/clear-cache", async (req, res) => {
  try {
    // Clear in-memory cache
    Object.keys(cache).forEach((key) => {
      cache[key] = { data: null, timestamp: null, lastRecordId: null };
    });

    // Delete cache files
    for (const key of Object.keys(cache)) {
      try {
        await fs.unlink(path.join(DATA_DIR, `${key}.json`));
      } catch (error) {
        // File might not exist, ignore
      }
    }

    res.json({ message: "All cache cleared successfully" });
  } catch (error) {
    console.error("Error clearing cache:", error);
    res.status(500).json({ error: "Failed to clear cache" });
  }
});

app.get("/api/wardrobe/items", async (req, res) => {
  try {
    const forceRefresh = req.query.refresh === "true";
    const items = await wardrobeService.getItems(forceRefresh);
    res.json(items);
  } catch (error) {
    console.error("Error fetching items:", error);
    res.status(500).json({ error: "Failed to fetch active items" });
  }
});

app.get("/api/wardrobe/inactive-items", async (req, res) => {
  try {
    const forceRefresh = req.query.refresh === "true";
    const items = await wardrobeService.getInactiveItems(forceRefresh);
    res.json(items);
  } catch (error) {
    console.error("Error fetching inactive items:", error);
    res.status(500).json({ error: "Failed to fetch inactive items" });
  }
});

app.get("/api/wardrobe/all-items", async (req, res) => {
  try {
    const forceRefresh = req.query.refresh === "true";
    const items = await wardrobeService.getAllItems(forceRefresh);
    res.json(items);
  } catch (error) {
    console.error("Error fetching all items:", error);
    res.status(500).json({ error: "Failed to fetch all items" });
  }
});

app.get("/api/wardrobe/outfits", async (req, res) => {
  try {
    const forceRefresh = req.query.refresh === "true";
    const outfits = await wardrobeService.getOutfits(forceRefresh);
    res.json(outfits);
  } catch (error) {
    console.error("Error fetching outfits:", error);
    res.status(500).json({ error: "Failed to fetch outfits" });
  }
});

app.get("/api/wardrobe/usage-log", async (req, res) => {
  try {
    const forceRefresh = req.query.refresh === "true";
    const usageLog = await wardrobeService.getUsageLog(forceRefresh);
    res.json(usageLog);
  } catch (error) {
    console.error("Error fetching usage log:", error);
    res.status(500).json({ error: "Failed to fetch usage log" });
  }
});

app.get("/api/wardrobe/inspiration", async (req, res) => {
  try {
    const forceRefresh = req.query.refresh === "true";
    const inspiration = await wardrobeService.getInspiration(forceRefresh);
    res.json(inspiration);
  } catch (error) {
    console.error("Error fetching inspiration:", error);
    res.status(500).json({ error: "Failed to fetch inspiration" });
  }
});

app.get("/api/wardrobe/shopping-list", async (req, res) => {
  try {
    const forceRefresh = req.query.refresh === "true";
    const shoppingList = await wardrobeService.getShoppingList(forceRefresh);
    res.json(shoppingList);
  } catch (error) {
    console.error("Error fetching shopping list:", error);
    res.status(500).json({ error: "Failed to fetch shopping list" });
  }
});

app.get("/api/wardrobe/avoids", async (req, res) => {
  try {
    const forceRefresh = req.query.refresh === "true";
    const avoids = await wardrobeService.getAvoids(forceRefresh);
    res.json(avoids);
  } catch (error) {
    console.error("Error fetching avoids:", error);
    res.status(500).json({ error: "Failed to fetch avoids list" });
  }
});

app.get("/api/wardrobe/analytics", async (req, res) => {
  try {
    const forceRefresh = req.query.refresh === "true";
    const analytics = await wardrobeService.analyzeUsagePatterns(forceRefresh);
    res.json(analytics);
  } catch (error) {
    console.error("Error analyzing patterns:", error);
    res.status(500).json({ error: "Failed to analyze usage patterns" });
  }
});

app.get("/api/wardrobe/cost-analysis", async (req, res) => {
  try {
    const forceRefresh = req.query.refresh === "true";
    const costAnalysis = await wardrobeService.getCostAnalysis(forceRefresh);
    res.json(costAnalysis);
  } catch (error) {
    console.error("Error analyzing costs:", error);
    res.status(500).json({ error: "Failed to analyze costs" });
  }
});

// Add this debug endpoint to your server.js to troubleshoot data flow

app.get("/api/debug/chat-data", async (req, res) => {
  try {
    const [
      activeItems,
      inactiveItems,
      outfits,
      usageLog,
      inspiration,
      shoppingList,
      avoids,
      analytics,
      costAnalysis,
    ] = await Promise.all([
      wardrobeService.getItems(false),
      wardrobeService.getInactiveItems(false),
      wardrobeService.getOutfits(false),
      wardrobeService.getUsageLog(false),
      wardrobeService.getInspiration(false),
      wardrobeService.getShoppingList(false),
      wardrobeService.getAvoids(false),
      wardrobeService.analyzeUsagePatterns(false),
      wardrobeService.getCostAnalysis(false),
    ]);

    const debugInfo = {
      rawDataCounts: {
        activeItems: activeItems?.length || 0,
        inactiveItems: inactiveItems?.length || 0,
        outfits: outfits?.length || 0,
        usageLog: usageLog?.length || 0,
        inspiration: inspiration?.length || 0,
        shoppingList: shoppingList?.length || 0,
        avoids: avoids?.length || 0,
      },

      sampleData: {
        firstActiveItem: activeItems?.[0] || null,
        firstUsageEntry: usageLog?.[0] || null,
        firstOutfit: outfits?.[0] || null,
      },

      analyticsStructure: {
        hasAnalytics: !!analytics,
        analyticsKeys: analytics ? Object.keys(analytics) : [],
        totalActiveItems: analytics?.totalActiveItems,
        totalUsageEntries: analytics?.totalUsageEntries,
        seasonalTrends: analytics?.seasonalTrends,
      },

      costAnalysisStructure: {
        hasCostAnalysis: !!costAnalysis,
        costAnalysisKeys: costAnalysis ? Object.keys(costAnalysis) : [],
        totalInvestment: costAnalysis?.totalInvestment,
      },

      cacheStatus: {
        items: {
          hasData: !!cache.items.data,
          count: cache.items.data?.length || 0,
          lastUpdated: cache.items.timestamp
            ? new Date(cache.items.timestamp).toISOString()
            : null,
        },
        usageLog: {
          hasData: !!cache.usageLog.data,
          count: cache.usageLog.data?.length || 0,
          lastUpdated: cache.usageLog.timestamp
            ? new Date(cache.usageLog.timestamp).toISOString()
            : null,
        },
      },
    };

    res.json(debugInfo);
  } catch (error) {
    console.error("Debug endpoint error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Replace your current /api/chat endpoint with this fixed version

app.post("/api/chat", async (req, res) => {
  try {
    const { message, context = [] } = req.body;

    console.log("Chat request received:", {
      message,
      contextLength: context.length,
    });

    // Use cached data (no fresh API calls during chat)
    const [
      activeItems,
      inactiveItems,
      outfits,
      usageLog,
      inspiration,
      shoppingList,
      avoids,
      analytics,
      costAnalysis,
    ] = await Promise.all([
      wardrobeService.getItems(false),
      wardrobeService.getInactiveItems(false),
      wardrobeService.getOutfits(false),
      wardrobeService.getUsageLog(false),
      wardrobeService.getInspiration(false),
      wardrobeService.getShoppingList(false),
      wardrobeService.getAvoids(false),
      wardrobeService.analyzeUsagePatterns(false),
      wardrobeService.getCostAnalysis(false),
    ]);

    console.log("Data fetched:", {
      activeItemsCount: activeItems?.length || 0,
      inactiveItemsCount: inactiveItems?.length || 0,
      outfitsCount: outfits?.length || 0,
      usageLogCount: usageLog?.length || 0,
      analyticsKeys: analytics ? Object.keys(analytics) : [],
      costAnalysisKeys: costAnalysis ? Object.keys(costAnalysis) : [],
    });

    // Create proper data structure that matches AI system prompt expectations
    const wardrobeData = {
      // Match the exact structure expected by the AI system prompt
      detailedAnalytics: analytics,
      costInsights: costAnalysis,

      // Create sample arrays with proper formatting
      activeItemsSample:
        activeItems?.slice(0, 15).map((item) => ({
          name: item.Name || item.name || "Unknown item",
          category: item.Category || item.category || "Unknown category",
          color: item.Color || item.color || "Unknown color",
          cost: item.Cost || item.cost || 0,
          brand: item.Brand || item.brand,
          season: item.Season || item.season,
        })) || [],

      recentUsageSample:
        usageLog?.slice(0, 10).map((usage) => ({
          date: usage.Date || usage.date || "Unknown date",
          item: Array.isArray(usage.Item)
            ? usage.Item[0]
            : usage.Item || usage.item || "Unknown item",
          occasion: usage.Occasion || usage.occasion || "unspecified",
          weather: usage.Weather || usage.weather,
          rating: usage.Rating || usage.rating,
        })) || [],

      referenceData: {
        shoppingListSample:
          shoppingList?.slice(0, 10).map((item) => ({
            Item: item.Item || item.Name || item.item || "Unknown item",
            Priority: item.Priority || item.priority,
            "Estimated Cost": item["Estimated Cost"] || item.cost || 0,
          })) || [],

        inspirationSample:
          inspiration?.slice(0, 5).map((item) => ({
            Source: item.Source || item.source,
            "Style Tags": item["Style Tags"] || item.tags,
            Notes: item.Notes || item.notes,
          })) || [],

        avoidsSample:
          avoids?.slice(0, 10).map((item) => ({
            Item: item.Item || item.Name || item.item || "Unknown item",
            Reason: item.Reason || item.reason,
          })) || [],
      },

      // Raw data for backup
      totalCounts: {
        activeItems: activeItems?.length || 0,
        inactiveItems: inactiveItems?.length || 0,
        outfits: outfits?.length || 0,
        usageEntries: usageLog?.length || 0,
        inspiration: inspiration?.length || 0,
        shoppingList: shoppingList?.length || 0,
        avoids: avoids?.length || 0,
      },
    };

    console.log("Structured wardrobe data:", {
      hasDetailedAnalytics: !!wardrobeData.detailedAnalytics,
      hasCostInsights: !!wardrobeData.costInsights,
      activeItemsSampleCount: wardrobeData.activeItemsSample?.length || 0,
      recentUsageSampleCount: wardrobeData.recentUsageSample?.length || 0,
      totalCounts: wardrobeData.totalCounts,
    });

    const response = await aiService.generateResponse(
      message,
      context,
      wardrobeData
    );

    res.json({ response });
  } catch (error) {
    console.error("Error processing chat:", error);
    res.status(500).json({
      error: "Failed to process message",
      details: error.message,
    });
  }
});

app.post("/api/evaluate-purchase", async (req, res) => {
  try {
    const { itemUrl, description } = req.body;

    const [analytics, activeItems, inactiveItems, costAnalysis] =
      await Promise.all([
        wardrobeService.analyzeUsagePatterns(false),
        wardrobeService.getItems(false),
        wardrobeService.getInactiveItems(false),
        wardrobeService.getCostAnalysis(false),
      ]);

    const wardrobeData = {
      activeItems,
      inactiveItems,
      analytics,
      costAnalysis,
    };

    const evaluation = await aiService.evaluatePurchase(
      itemUrl,
      description,
      wardrobeData
    );

    res.json({ evaluation });
  } catch (error) {
    console.error("Error evaluating purchase:", error);
    res.status(500).json({ error: "Failed to evaluate purchase" });
  }
});

// Initialize and start server
initializeApp()
  .then(() => {
    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
      console.log(`Health check: http://localhost:${PORT}/api/health`);
    });
  })
  .catch((error) => {
    console.error("Failed to initialize app:", error);
    process.exit(1);
  });

module.exports = app;
